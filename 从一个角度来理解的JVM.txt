JVM是java虚拟机的缩写。包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆、一个存储方法域。
JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码(字节码)，就可以在多种平台上不加修改地运行。
JVM在执行字节码时，最终还是把字节码解释成具体平台上的机器指令执行。

Java虚拟机是实现平台无关性的关键。一次编译，到处运行

JRE：java运行环境
JDK：程序开发者用来编译、调试java程序的开发工具包
JVM：是JRE的一部分，是一个虚构出来的计算机

JVM执行程序的过程：
	加载.class文件	管理并分配内存	执行垃圾收集
	
JVM生命周期：
	JVM实例对应了一个独立运行的java程序，它是进程级别
	启动。启动一个java程序时，一个JVM实例就产生了，任何一个拥有public static void main函数的class都可以作为JVM实例运行的起点
	运行。main()作为该程序初始线程的起点，任何其他线程均由该线程启动。
	消亡。当程序中的所有非守护线程都终止时，JVM才退出。
	
JVM体系结构：
	类加载器(用来装载.class文件)
	执行引擎(执行字节码，或者执行本地方法)
	运行时数据区(方法区、堆、java栈、PC寄存器、本地方法栈)
	
JVM运行时数据区：
	PC寄存器：存储每个线程下一步将执行的JVM指令
	JVM栈：栈是线程私有的，每个线程创建的同时都会创建JVM栈，JVM栈中存放的是当前线程中的基本类型的局部变量，部分返回结果，
	非基本类型的对象在JVM栈上仅存放一个指向堆上的地址。
	
	堆：用来存储对象实例及数组织的区域。Java中所有通过new创建的对象的内存在此分配。
		堆是JVM中所有线程共享的，因此在其上进行对象分配均需要进行加锁
		Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间TLAB，其大小由JVM根据运算而得，
	在TLAB上分配对象时不需要加锁，因此JVM在给线程的对象分配内存时会尽量在TLAB上分配。
		TLAB仅用作新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效。
		 所有新创建的Object 都将会存储在新生代Yong Generation中。如果Young Generation的数据在一次或多次GC后存活下来，那么将被转移到OldGeneration。新的Object总是创建在Eden Space。
	
	方法区域：存放了所加载的类的信息、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息
	运行时常量池：存放类中固定的常量信息、方法和Field的引用信息等，其空间从方法区域中分配
	本地方法堆栈：用来支持native方法的执行，此区域用于存储每个native方法调用的状态
		native方法：一个java调用非java代码的接口
		
JVM垃圾回收：
	GC的基本原理：
		将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和事件，Java在对对象
	的生命周期特征进行分析后，按照新生代、旧生代的方式对对象进行收集，以尽可能的缩短GC对应用造成的暂停
		对新生代的对象的收集称为minor GC，对旧生代的对象的收集称为Full GC，程序中主动调用System.gc()强制执行的称为Full GC	
	
	不同的对象引用类型，GC会采用不同的方法进行回收，JVM对象的引用分为了四种类型：
		强引用：默认情况下，对象采用的均为强引用(这个对象的实例没有其他对象引用，GC才会被回收)
		软引用：软引用是Java中提供的一种比较适用于缓存场景的应用(只有内存不够用的情况下才会被GC)
		弱引用：在GC时一定会被GC回收
		虚引用：虚引用只是用来得知对象是否被GC
		
	GC算法：